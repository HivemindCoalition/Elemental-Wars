<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Player_Placeholder</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pixel Scale
meter = 48;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialization variables

//resource stats
current_health = 100;
max_health = 100;
current_stam = 100;
max_stam = 100;
current_SE = 100;
max_SE = 100;
curr_phys_endur = 100;
max_phys_endur = 100;
curr_meta_endur = 100;
max_meta_endur = 100;

//base stats
max_strength = 200;
avail_str = max_strength;
max_agi = 10;
avail_agi = max_agi;
max_dex = 10;
avail_dex = max_dex;
max_int = 10;
avail_int = max_int;
max_spi = 10;
avail_spi = max_spi;

//state machine variables
basic_move_state = 0;
acrobat_move_state = 0;
combat_move_state = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step Timer Initialization
//Everytime a movement ability is used, step counter counts down until next action can be input
Step_timer_active = 0;
Step_timer_count = 0;
Step_timer_completed = false;
first_step = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Facing/Aiming Initializtion

//facing/aiming properties
facing_dir = 0;//can be either left or right, based on mouse position from player
aiming_dir = 0;//can be 0-359, and based on mouse position from player
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Physics Initialization

//physics properties
mass = 68; //based off metric system
momentum_for = 0;
momentum_dir = 0;
run_accel = 0;
sprint_accel = 0;

//drag coefficient
CD = 1;
//cross section area
CA = 3.6*meter;
//air density
RA = 1.2;

drag = (1/2)*CD*CA*RA*(speed/meter);

//force variables
max_force = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mobility Abilities
//This includes basic movements such as walk/run/sprint, as well as advance acrobatics
walking = 0;
running = 0;
sprinting = 0;


//Walking
technique_mobility_walking = 1; //abilities will be objects as well down the road
technique_walking_stepSpeed = .30;
technique_walking_technique = 1;


//Running
technique_mobility_running = 1; //abilities will be objects as well down the road
technique_running_stepSpeed = 0.5;
technique_running_technique = 1;

//Sprinting
technique_mobility_sprintng = 1; //abilities will be objects as well down the road
technique_sprinting_stepSpeed = 1;
technique_sprinting_technique = 1;

//power bar info
//0-30 - walking
//30-80 - running
//80-100 - sprinting
mobility_power_current = 0;//tracks bar progress
mobility_power_used = 0;//indicates power used based on bar progress

//ability derivative updates
technique_walking_stepForce = avail_str * technique_walking_technique;//this is the amount of force put down on every step
technique_running_stepForce = avail_str * technique_running_technique;//this is the amount of force put down on every step
technique_sprinting_stepForce = avail_str * technique_sprinting_technique;//this is the amount of force put down on every step
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///State Flags
on_ground = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Odometer Init
max_meters_sec_prev = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Odometer
meters_sec = (speed/meter)*room_speed;
if(meters_sec &gt; max_meters_sec_prev)
{
    max_meters_sec_prev = meters_sec;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Aiming/facing direction

/*
This code gets mouse info from player controller
and uses it to set aiming/facing direction
*/

aiming_dir = point_direction(x,y,mouse_x,mouse_y);
if(aiming_dir &gt; 270 || aiming_dir &lt; 90)
{
    facing_dir = 0;
    facing_right = true;
    facing_left = false;
}
else
{
    facing_dir = 180;
    facing_left = true;
    facing_right = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Movement State Machine

/*
Basic Movement State Machine
all movement is:
in the direction of the key pressed
in the opposite direction of facing if moving backwards
you are going forward if you are facing the direction you're moving
0 = nothing
1 = walking_left
2 = running_left - can only run going forwards
3 = sprinting_lefy - can only sprint going fowards
4 = walking_right
5 = running_right - can only run going forwards
6 = sprinting_right - can only sprint going fowards

If you try to run or sprint going backwards, you will just walk
*/

/*
Players running speed will accelerate until maximum move speed is reached
*/

if(on_ground == true)
{
    switch(basic_move_state)
    {
        case 0://no state entered
            friction = 0.1;
            walking = 0;
            running = 0;
            sprinting = 0;
        break;
        case 1:
        if(facing_dir == 180){walking = 1;running = 0;sprinting = 0;}
        else{}
        break;
        case 2:
        if(facing_dir == 180){walking = 0;running = 1;sprinting = 0;}
        else{}
        break;
        case 3:
        if(facing_dir == 180){walking = 0;running = 0;sprinting = 1;}
        else{}
        break;
        case 4:
        if(facing_dir == 0){walking = 1;running = 0;sprinting = 0;}
        else{}
        break;
        case 5:
        if(facing_dir == 0){walking = 0;running = 1;sprinting = 0;}
        else{}
        break;
        case 6:
        if(facing_dir == 0){walking = 0;running = 0;sprinting = 1;}
        else{}
        break;
        default:
        ;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Acrobatics State Machine
/*
all movement is:
in the direction of the key pressed
in the opposite direction of facing if moving backwards
you are going forward if you are facing the direction you're moving
0 = nothing
1 = jumping
2 = running_left - can only run going forwards
3 = sprinting_lefy - can only sprint going fowards
4 = walking_right
5 = running_right - can only run going forwards
6 = sprinting_right - can only sprint going fowards

If you try to run or sprint going backwards, you will just walk
*/

/*
Players running speed will accelerate until maximum move speed is reached
*/

switch(acrobatic_move_state)
{
    case 0://no state entered
    break;
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    default:
    ;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///physics calculations/updates
//physics properties
momentum_dir = direction;
current_force = mass * speed/meter*meter;
if(current_force &gt; max_force)
{
    max_force = current_force;
}
drag = (1/2)*CD*CA*RA*(speed/meter);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mobility Ability behaviors
//This includes basic movements such as walk/run/sprint, as well as advance acrobatics

//power bar info
//The power bar will determine how much strength is being used with the mobility abilities
//0-30 - walking
//30-80 - running
//80-100 - sprinting
mobility_power_used = avail_str*(mobility_power_current/100);

//ability derivative updates
technique_walking_stepForce = mobility_power_used * technique_walking_technique;//this is the amount of force put down on every step
technique_walking_accel = technique_walking_stepForce/mass;

technique_running_stepForce = mobility_power_used * technique_running_technique;//this is the amount of force put down on every step
technique_running_accel = technique_running_stepForce/mass;

technique_sprinting_stepForce = mobility_power_used * technique_sprinting_technique;//this is the amount of force put down on every step
technique_sprinting_accel = technique_sprinting_stepForce/mass;


//behaviors
if(walking == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_walking_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 30;
        hspeed += cos(degtorad(facing_dir))*technique_walking_accel;
        Step_timer_count = technique_walking_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
}
if(running == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 70;
        hspeed += cos(degtorad(facing_dir))*technique_running_accel;
        current_stam -= 10;
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
    else if(!first_step &amp;&amp; !Step_timer_completed)
    {
    }
}
if(sprinting == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 90;
        current_stam -= 20;
        hspeed += cos(degtorad(facing_dir))*technique_sprinting_accel;
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
    else if(!first_step &amp;&amp; !Step_timer_completed)
    {
    }
}
else{}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step Timers and Behaviors
//Step timer
if((Step_timer_active == 1) &amp;&amp; Step_timer_completed)
{
    Step_timer_count--;
    
    Step_timer_completed = false;
}
else if(Step_timer_active == 1)
{
    Step_timer_count--;
}

if(Step_timer_count &lt;= 0)
{
    Step_timer_completed = true;
    Step_timer_active = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Acrobatic Ability Behaviors
//This includes acrobatic movements such as jump/climb/swim, as well as advance acrobatics

//power bar info
//The power bar will determine how much strength is being used with the mobility abilities
//0-30 - walking
//30-80 - running
//80-100 - sprinting
mobility_power_used = avail_str*(mobility_power_current/100);

//ability derivative updates
technique_walking_stepForce = mobility_power_used * technique_walking_technique;//this is the amount of force put down on every step
technique_walking_accel = technique_walking_stepForce/mass;

technique_running_stepForce = mobility_power_used * technique_running_technique;//this is the amount of force put down on every step
technique_running_accel = technique_running_stepForce/mass;

technique_sprinting_stepForce = mobility_power_used * technique_sprinting_technique;//this is the amount of force put down on every step
technique_sprinting_accel = technique_sprinting_stepForce/mass;


//behaviors
if(walking == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_walking_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 30;
        hspeed += cos(degtorad(facing_dir))*technique_walking_accel;
        Step_timer_count = technique_walking_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
}
if(running == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 70;
        hspeed += cos(degtorad(facing_dir))*technique_running_accel;
        current_stam -= 10;
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
    else if(!first_step &amp;&amp; !Step_timer_completed)
    {
    }
}
if(sprinting == 1)
{
    if(first_step)//activate step timer on first step
    {
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
        first_step = false;
    }
    else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
    {
        mobility_power_current = 90;
        current_stam -= 20;
        hspeed += cos(degtorad(facing_dir))*technique_sprinting_accel;
        Step_timer_count = technique_running_stepSpeed*room_speed;
        Step_timer_active = 1;
    }
    else if(!first_step &amp;&amp; !Step_timer_completed)
    {
    }
}
else{}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(current_stam &lt;= max_stam)
{
    current_stam += 10/room_speed;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
