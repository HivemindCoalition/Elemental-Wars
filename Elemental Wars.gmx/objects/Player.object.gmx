<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Player_Placeholder</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pixel Scale
meter = 48;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialization variables

//resource stats
current_health = 100;
max_health = 100;
current_stam = 100;
max_stam = 100;
current_SE = 100;
max_SE = 100;
curr_phys_endur = 100;
max_phys_endur = 100;
curr_meta_endur = 100;
max_meta_endur = 100;

//base stats
max_strength = 200;
avail_str = max_strength;
max_agi = 10;
avail_agi = max_agi;
max_dex = 10;
avail_dex = max_dex;
max_int = 10;
avail_int = max_int;
max_spi = 10;
avail_spi = max_spi;

//state machine variables
basic_move_state = 0;
acrobat_move_state = 0;
combat_move_state = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step Timer Initialization
//Everytime a movement ability is used, step counter counts down until next action can be input
Step_timer_active = 0;
Step_timer_count = 0;
Step_timer_completed = false;
first_step = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Facing/Aiming Initializtion

//facing/aiming properties
facing_dir = 0;//can be either left or right, based on mouse position from player
aiming_dir = 0;//can be 0-359, and based on mouse position from player
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Physics Initialization

//physics properties
mass = 68; //based off metric system
momentum_for = 0;
momentum_dir = 0;
run_accel = 0;
sprint_accel = 0;

//drag coefficient
Cd = .6;
//cross section area
CA = 2;
//air density
Ad = 1.2;

drag = -((1/2)*Ad*(speed/meter)*Cd*CA);

//force variables
max_force = 0;

//potential variables for collision
p_vspeed = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mobility Abilities
//This includes basic movements such as walk/run/sprint, as well as advance acrobatics
walking = 0;
running = 0;
sprinting = 0;


//Walking
technique_mobility_walking = 4; //abilities will be objects as well down the road
technique_walking_stepSpeed = .45;


//Running
technique_mobility_running = 1; //abilities will be objects as well down the road
technique_running_stepSpeed = 0.65;

//Sprinting
technique_mobility_sprinting = 1; //abilities will be objects as well down the road
technique_sprinting_stepSpeed = .85;

//power bar info
//0-30 - walking
//30-80 - running
//80-100 - sprinting
mobility_power_current = 0;//tracks bar progress
mobility_power_used = 0;//indicates power used based on bar progress

//ability derivative updates
technique_walking_stepForce = mobility_power_used * technique_mobility_walking;//this is the amount of force put down on every step
technique_running_stepForce = mobility_power_used * technique_mobility_running;//this is the amount of force put down on every step
technique_sprinting_stepForce = mobility_power_used * technique_mobility_sprinting;//this is the amount of force put down on every step
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Acrobrobatic Abilities

//This includes basic movements such as walk/run/sprint, as well as advance acrobatics
jumping = 0;

//Jumping
technique_acrobatic_jumping = 1; //abilities will be objects as well down the road
technique_jumping_stepSpeed = .30;



//power bar info
//0-30 - walking
//30-80 - running
//80-100 - sprinting
acrobatic_power_current = 0;//tracks bar progress
acrobatic_power_used = 0;//indicates power used based on bar progress

//ability derivative updates
technique_jumping_stepForce = avail_str * technique_acrobatic_jumping;//this is the amount of force put down on every step
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///State Flags
on_ground = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Odometer Init
max_meters_sec_prev = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///state machine variables
basic_move_state = 0;
acrobatic_move_state = 0;
combat_move_state = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement Variables
hsp = 0;
vsp = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Odometer
meters_sec = (speed/meter)*room_speed;
if(meters_sec &gt; max_meters_sec_prev)
{
    max_meters_sec_prev = meters_sec;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Aiming/facing direction

/*
This code gets mouse info from player controller
and uses it to set aiming/facing direction
*/

aiming_dir = point_direction(x,y,mouse_x,mouse_y);
if(aiming_dir &gt; 270 || aiming_dir &lt; 90)
{
    facing_dir = 0;
    facing_right = true;
    facing_left = false;
}
else
{
    facing_dir = 180;
    facing_left = true;
    facing_right = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///2D Collision Check

//Ground Check
if(place_meeting(x,y+1,Floor)){on_ground = true;}else{on_ground = false;}
//ollision below
if(vsp &gt; 0 &amp;&amp; place_meeting(x,y+vsp,Floor)){collision_below = true;}else{collision_below = false;}
//collision above
if(vsp &lt; 0 &amp;&amp; place_meeting(x,y+vsp,Floor)){collision_above = true;}else{collision_above = false;}



if(hsp &gt; 0 &amp;&amp; place_meeting(x+hsp,y,Floor)){collision_right = true;}else{collision_right = false;}
if(hsp &lt; 0 &amp;&amp; place_meeting(x+hsp,y,Floor)){collision_left = true;}else{collision_left = false;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Mobility State Machine

/*
Basic Movement State Machine
all movement is:
in the direction of the key pressed
in the opposite direction of facing if moving backwards
you are going forward if you are facing the direction you're moving
0 = nothing
1 = walking_left
2 = running_left - can only run going forwards
3 = sprinting_lefy - can only sprint going fowards
4 = walking_right
5 = running_right - can only run going forwards
6 = sprinting_right - can only sprint going fowards

If you try to run or sprint going backwards, you will just walk
*/

/*
Players running speed will accelerate until maximum move speed is reached
*/

if(on_ground)
{
    switch(basic_move_state)
    {
        case 0://no state entered
            friction = 0.05;
            walking = 0;
            running = 0;
            sprinting = 0;
        break;
        case 1:
        if(facing_dir == 180){walking = 1;running = 0;sprinting = 0;}
        else{}
        break;
        case 2:
        if(facing_dir == 180){walking = 0;running = 1;sprinting = 0;}
        else{}
        break;
        case 3:
        if(facing_dir == 180){walking = 0;running = 0;sprinting = 1;}
        else{}
        break;
        case 4:
        if(facing_dir == 0){walking = 1;running = 0;sprinting = 0;}
        else{}
        break;
        case 5:
        if(facing_dir == 0){walking = 0;running = 1;sprinting = 0;}
        else{}
        break;
        case 6:
        if(facing_dir == 0){walking = 0;running = 0;sprinting = 1;}
        else{}
        break;
        default:
        ;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Acrobatics State Machine
/*
all movement is:
in the direction of the key pressed
in the opposite direction of facing if moving backwards
you are going forward if you are facing the direction you're moving
0 = nothing
1 = jumping
2 = running_left - can only run going forwards
3 = sprinting_lefy - can only sprint going fowards
4 = walking_right
5 = running_right - can only run going forwards
6 = sprinting_right - can only sprint going fowards

If you try to run or sprint going backwards, you will just walk
*/

/*
Players running speed will accelerate until maximum move speed is reached
*/
if(on_ground)
{
    switch(acrobatic_move_state)
    {
        case 0://no state entered
        jumping = 0;
        break;
        case 1:
        jumping = 1;
        break;
        case 2:
        break;
        case 3:
        break;
        case 4:
        break;
        case 5:
        break;
        case 6:
        break;
        default:
        ;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mobility Ability behaviors
//The power bar will determine how much strength is being used with the mobility abilities
//0-30 - walking
//30-80 - running
//80-100 - sprinting
if(on_ground)
{
    if(walking == 1)
    {
        if(first_step)//activate step timer on first step
        {
            Step_timer_count = technique_walking_stepSpeed*room_speed;
            Step_timer_active = 1;
            first_step = false;
        }
        else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
        {
            show_debug_message("entered walking");
            mobility_power_used = 30;
            //ability derivative updates
            technique_walking_stepForce = mobility_power_used * technique_mobility_walking;//this is the amount of force put down on every step
            technique_walking_accel = technique_walking_stepForce/mass;
            hsp += cos(degtorad(facing_dir))*technique_walking_accel;
            Step_timer_count = technique_walking_stepSpeed*room_speed;
            Step_timer_active = 1;
        }
    }
    if(running == 1)
    {
        if(first_step)//activate step timer on first step
        {
            Step_timer_count = technique_running_stepSpeed*room_speed;
            Step_timer_active = 1;
            first_step = false;
        }
        else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
        {
            show_debug_message("entered running");
            mobility_power_used = 65;
            //ability derivative updates
            technique_running_stepForce = mobility_power_used * technique_mobility_running;//this is the amount of force put down on every step
            technique_running_accel = technique_running_stepForce/mass;
            hsp += cos(degtorad(facing_dir))*technique_running_accel;
            Step_timer_count = technique_running_stepSpeed*room_speed;
            Step_timer_active = 1;
        }
    }
    if(sprinting == 1)
    {
        if(first_step)//activate step timer on first step
        {
            Step_timer_count = technique_sprinting_stepSpeed*room_speed;
            Step_timer_active = 1;
            first_step = false;
        }
        else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
        {
            show_debug_message("entered sprinting");
            mobility_power_used = 90;
            //ability derivative updates
            technique_sprinting_stepForce = mobility_power_used * technique_mobility_sprinting;//this is the amount of force put down on every step
            technique_sprinting_accel = technique_sprinting_stepForce/mass;
            hsp += cos(degtorad(facing_dir))*technique_sprinting_accel;
            Step_timer_count = technique_sprinting_stepSpeed*room_speed;
            Step_timer_active = 1;
        }
    }
}
else{}



//behaviors
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Acrobatic Ability Behaviors
//This includes acrobatic movements such as jump/climb/swim, as well as advance acrobatics

//power bar info
//The power bar will determine how much strength is being used with the mobility abilities
//0-30 - walking
//30-80 - running
//80-100 - sprinting
acrobatic_power_used = avail_str*(acrobatic_power_current/100);

//ability derivative updates
technique_jumping_stepForce = acrobatic_power_used * technique_acrobatic_jumping;//this is the amount of force put down on every step
technique_jumping_accel = technique_jumping_stepForce/mass;

//behaviors
if(on_ground)
{
    if(jumping == 1)
    {
        if(first_step)//activate step timer on first step
        {
            Step_timer_count = technique_jumping_stepSpeed*room_speed;
            Step_timer_active = 1;
            first_step = false;
        }
        else if(!first_step &amp;&amp; Step_timer_completed)//each step reloads and reactivates step timer
        {
            acrobatic_power_current = 100;
            vsp -= technique_jumping_accel;
            Step_timer_count = technique_jumping_stepSpeed*room_speed;
            Step_timer_active = 1;
        }
    }
}
else{}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step Timers and Behaviors
//Step timer
if((Step_timer_active == 1) &amp;&amp; Step_timer_completed)
{
    Step_timer_count--;
    
    Step_timer_completed = false;
}
else if(Step_timer_active == 1)
{
    Step_timer_count--;
}

if(Step_timer_count &lt;= 0)
{
    Step_timer_completed = true;
    Step_timer_active = 0;
}
//reset first step and deactivate timer
//if player stops moving and the step timer has finished from the last move
//reactivate first step
/*if(momentum == 0 &amp;&amp; Step_timer_completed == 1)
{
    first_step = true;
    Step_timer_active = 0;
}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stamina Regeneration
if(current_stam &lt;= max_stam)
{
    current_stam += 10/room_speed;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Physics calculations/updates
//Physics properties
momentum_dir = direction;
momentum = mass * speed/meter*meter;
if(momentum &gt; max_force)
{
    max_force = momentum;
}
drag = -((1/2)*Ad*(speed/meter)*Cd*CA);

//hspeed += (drag/mass)*cos(degtorad(facing_dir));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Gravity
if(!on_ground)
{
        grav += (9.8/meter)/room_speed;
}
else
{
    grav = 0;
    vspeed = 0;
}
vsp += grav;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Charge Bars
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///apply movement
if(!collision_left)
{
    hspeed = hsp;
}
if(!collision_right)
{
    hspeed = hsp;
}
if(!collision_below)
{
    vspeed = vsp;
}
else
{
    move_contact_all(270, vsp);
    vsp = 0;
}
if(!collision_above)
{
    vspeed = vsp;
}
else
{
    vsp = 0;
    move_contact_all(90, vsp);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,0</point>
    <point>32,64</point>
    <point>0,64</point>
  </PhysicsShapePoints>
</object>
